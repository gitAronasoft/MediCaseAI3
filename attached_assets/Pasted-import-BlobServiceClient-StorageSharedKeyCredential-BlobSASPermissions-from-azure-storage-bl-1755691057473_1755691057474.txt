import { BlobServiceClient, StorageSharedKeyCredential, BlobSASPermissions } from "@azure/storage-blob";
import { DocumentAnalysisClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
import { SearchClient, SearchIndexClient, AzureKeyCredential as SearchCredential } from "@azure/search-documents";
import OpenAI from "openai";

// Azure Storage Client
export const blobServiceClient = new BlobServiceClient(
  `https://${process.env.AZURE_STORAGE_ACCOUNT_NAME}.blob.core.windows.net`,
  new StorageSharedKeyCredential(
    process.env.AZURE_STORAGE_ACCOUNT_NAME!,
    process.env.AZURE_STORAGE_ACCOUNT_KEY!
  )
);

// Azure Document Intelligence Client
export const documentAnalysisClient = new DocumentAnalysisClient(
  process.env.AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT!,
  new AzureKeyCredential(process.env.AZURE_DOCUMENT_INTELLIGENCE_KEY!)
);

// Azure Search Clients
export const searchIndexClient = new SearchIndexClient(
  process.env.AZURE_SEARCH_ENDPOINT!,
  new SearchCredential(process.env.AZURE_SEARCH_ADMIN_KEY!)
);

export const searchClient = new SearchClient(
  process.env.AZURE_SEARCH_ENDPOINT!,
  "documents-index",
  new SearchCredential(process.env.AZURE_SEARCH_ADMIN_KEY!)
);

// Azure OpenAI Client
export const azureOpenAI = new OpenAI({
  apiKey: process.env.AZURE_OPENAI_API_KEY,
  baseURL: `${process.env.AZURE_OPENAI_ENDPOINT}/openai/deployments/${process.env.AZURE_OPENAI_DEPLOYMENT_NAME}`,
  defaultQuery: { 'api-version': process.env.AZURE_OPENAI_API_VERSION },
  defaultHeaders: {
    'api-key': process.env.AZURE_OPENAI_API_KEY,
  },
});

// Document Processing Service
export class HybridDocumentProcessor {
  private containerName = "documents";

  // 1. Upload document to Azure Storage
  async uploadToAzureStorage(fileName: string, fileBuffer: Buffer): Promise<string> {
    const containerClient = blobServiceClient.getContainerClient(this.containerName);
    
    // Ensure container exists
    await containerClient.createIfNotExists();

    const blobName = `${Date.now()}-${fileName}`;
    const blockBlobClient = containerClient.getBlockBlobClient(blobName);
    
    await blockBlobClient.upload(fileBuffer, fileBuffer.length, {
      blobHTTPHeaders: {
        blobContentType: this.getMimeType(fileName)
      }
    });

    return blobName;
  }

  // 2. Extract text using Azure Document Intelligence
  async extractTextWithDocumentIntelligence(azureStoragePath: string): Promise<string> {
    try {
      console.log(`ü§ñ Analyzing document with Azure Document Intelligence: ${azureStoragePath}`);
      
      // Get the full blob URL for Document Intelligence
      const blobUrl = `https://${process.env.AZURE_STORAGE_ACCOUNT_NAME}.blob.core.windows.net/${this.containerName}/${azureStoragePath}`;
      
      // Generate SAS token for Document Intelligence access
      const sasToken = await this.generateSasToken(azureStoragePath);
      const documentUrl = `${blobUrl}?${sasToken}`;
      
      console.log(`üìÑ Processing document from: ${blobUrl}`);
      
      // Start the analysis using Document Intelligence
      const poller = await documentAnalysisClient.beginAnalyzeDocumentFromUrl(
        "prebuilt-document", // Use prebuilt model for general document analysis
        documentUrl
      );
      
      console.log('‚è≥ Waiting for Document Intelligence analysis to complete...');
      const result = await poller.pollUntilDone();
      
      if (result.content && result.content.trim()) {
        console.log(`‚úÖ Extracted ${result.content.length} characters from document with Document Intelligence`);
        return result.content.trim();
      } else {
        throw new Error("No content extracted from document");
      }
    } catch (error) {
      console.error("Azure Document Intelligence error:", error);
      throw new Error(`Failed to extract text with Document Intelligence: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Helper method to generate SAS token for blob access
  private async generateSasToken(blobName: string): Promise<string> {
    try {
      const containerClient = blobServiceClient.getContainerClient(this.containerName);
      const blobClient = containerClient.getBlobClient(blobName);
      
      // Generate SAS token valid for 1 hour
      const expiryTime = new Date();
      expiryTime.setHours(expiryTime.getHours() + 1);
      
      const sasUrl = await blobClient.generateSasUrl({
        permissions: BlobSASPermissions.parse("r"), // read permission
        expiresOn: expiryTime
      });
      
      // Extract just the SAS token part from the URL
      const url = new URL(sasUrl);
      return url.search.substring(1); // Remove the '?' prefix
    } catch (error) {
      console.error("Error generating SAS token:", error);
      throw error;
    }
  }

  // 3. Index document in Azure Search
  async indexDocument(documentId: string, fileName: string, extractedText: string): Promise<string> {
    try {
      // First ensure the search index exists
      await this.ensureSearchIndexExists();
      
      // Create search document
      const searchDocument = {
        id: documentId,
        fileName: fileName,
        content: extractedText,
        lastModified: new Date().toISOString()
      };

      // Upload to search index
      const uploadResult = await searchClient.uploadDocuments([searchDocument]);
      
      if (uploadResult.results[0].succeeded) {
        console.log(`‚úÖ Document indexed successfully in Azure Search: ${documentId}`);
        return documentId;
      } else {
        throw new Error("Failed to index document");
      }
    } catch (error) {
      console.error("Azure Search indexing error:", error);
      // Don't fail the entire process if search indexing fails
      console.log('‚ö†Ô∏è Search indexing failed, continuing without search...');
      return documentId;
    }
  }

  // Method to ensure index exists before indexing
  async ensureSearchIndexExists() {
    try {
      await searchIndexClient.getIndex('documents-index');
    } catch (error: any) {
      if (error.statusCode === 404) {
        console.log('Search index not found, creating it...');
        await initializeSearchIndex();
        // Wait a bit for the index to be fully created
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        throw error;
      }
    }
  }

  // 4. Enhanced analysis with Azure OpenAI
  async enhanceAnalysisWithOpenAI(extractedText: string): Promise<any> {
    try {
      const response = await azureOpenAI.chat.completions.create({
        model: process.env.AZURE_OPENAI_DEPLOYMENT_NAME || "gpt-4o",
        messages: [
          {
            role: "system",
            content: "You are a document analysis expert. Analyze the provided text and extract key information in JSON format. Include documentType, entities (people, organizations, locations, dates), and insights about the document."
          },
          {
            role: "user",
            content: `Analyze this document text and provide structured insights:\n\n${extractedText.substring(0, 4000)}`
          }
        ],
        response_format: { type: "json_object" },
        max_tokens: 1000
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      
      return {
        documentType: analysis.documentType || 'Document',
        entities: analysis.entities || [],
        tables: analysis.tables || [],
        insights: analysis.insights || []
      };
    } catch (error) {
      console.error("Azure OpenAI analysis error:", error);
      return {
        documentType: 'Document',
        entities: [],
        tables: [],
        insights: [
          {
            type: 'Processing Note',
            description: 'Enhanced AI analysis temporarily unavailable',
            icon: 'info'
          }
        ]
      };
    }
  }

  // Helper method to determine MIME type
  private getMimeType(fileName: string): string {
    const extension = fileName.toLowerCase().split('.').pop();
    switch (extension) {
      case 'pdf': return 'application/pdf';
      case 'jpg':
      case 'jpeg': return 'image/jpeg';
      case 'png': return 'image/png';
      case 'gif': return 'image/gif';
      case 'txt': return 'text/plain';
      case 'doc': return 'application/msword';
      case 'docx': return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      default: return 'application/octet-stream';
    }
  }
}

// Initialize search index
export async function initializeSearchIndex() {
  try {
    console.log('üîç Initializing Azure Search index...');
    
    const indexExists = await searchIndexClient.getIndex('documents-index').catch(() => null);
    
    if (!indexExists) {
      console.log('Creating search index...');
      
      const index = {
        name: 'documents-index',
        fields: [
          {
            name: 'id',
            type: 'Edm.String' as const,
            key: true,
            filterable: true
          },
          {
            name: 'fileName',
            type: 'Edm.String' as const,
            searchable: true,
            filterable: true,
            sortable: true
          },
          {
            name: 'content',
            type: 'Edm.String' as const,
            searchable: true,
            analyzerName: 'standard.lucene'
          },
          {
            name: 'lastModified',
            type: 'Edm.DateTimeOffset' as const,
            filterable: true,
            sortable: true
          }
        ]
      };
      
      await searchIndexClient.createIndex(index);
      console.log('‚úÖ Search index created successfully');
    } else {
      console.log('‚úÖ Search index already exists');
    }
  } catch (error) {
    console.error('‚ùå Failed to initialize search index:', error);
    // Don't throw error to prevent app startup failure
  }
}